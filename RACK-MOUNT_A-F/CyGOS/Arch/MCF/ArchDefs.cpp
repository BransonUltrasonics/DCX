// $Header:   D:/databases/VMdb/archives/DCX/RackMount/A&F/WC/CyGOS/Arch/MCF/ArchDefs.cpp_v   1.0   09 Jun 2015 09:13:26   tayars  $
//
// Copyright (c) Cyber Group, Inc 2007
// This program is the property of Cyber Group Inc
// Copying of this software is expressly forbidden, without the prior written
// consent of Cyber Group Inc
//
// This file is part of CyGOS-3.
//
// This module implements CPU architecture-specific routines.

// FIXME Implement interrupt stacks.
// FIXME Verify static object initialization.
// FIXME Implement CppDoc build target
// FIXME MisAlignedShort/Long and NetShort/Long: Figure out which one is needed and which one is not.
// MisAligned is used in LWIP in the code that fixes endianness when packets are
// received, NetShort/Long must be used in structures that are transmitted over
// network without LWIP endianness correction.

#include "ArchDefs.h"
#include "assert.h"
#include "DebugNew.h"
#include "string.h"

/**
 * EnterCritical: Freescale ColdFire-specific function to enter critical section
 * of code with interrupts disabled. Function modifies CPU status register to
 * disable interrupts. Old status register value is returned so that interrupts
 * can be enabled at the critical section exit, but only if interrupts were
 * enabled when code section was entered.
 * @return SR CPU status register value before interrupts were disabled.
 */
SR EnterCritical()
{
	SR sr;
	asm volatile ("move.w %%sr,%0": "=d"(sr));
	asm volatile ("move.w #0x2700,%%d1\n\tmove.w %%d1,%%sr" : : : "%%d1");
	return sr;
}

/**
 * ExitCritical: Freescale ColdFire-specific function to exit critical section
 * of code, restoring previous interrupt enable/disable status.
 * @param sr CPU status register value before entering a critical section. The
 * value may have interrupts disabled or enabled, interrupts will be restored
 * to the previous state.
 */
void ExitCritical(SR sr)
{
	asm volatile ("move.w %0,%%sr": : "d"(sr));
}

/**
 * DisableInterrupts: Disable all interrupts. Function only operates on CPU
 * interrupt level register.
 */
void DisableInterrupts()
{
	asm volatile ("move.w #0x2700,%d0\n\tmove.w %d0,%sr");
}

/**
 * EnableInterrupts: Enable all interrupts. Function only operates on CPU
 * interrupt level register.
 */
void EnableInterrupts()
{
	asm volatile ("move.w #0x2000,%d0\n\tmove.w %d0,%sr");
}

/**
 * __cxa_pure_virtual: This function address is placed into an object virtual
 * method table for functions marked as pure virtual. The pure virtual functions
 * may be called if base class has the pure virtual function and derived class
 * does not override the function.
 */
extern "C" void __cxa_pure_virtual()
{
	CRASH("Pure virtual function called");
}

extern "C" void __cxa_guard_acquire()
{
}

extern "C" void __cxa_guard_release()
{
}

/**
 * __dso_handle: A handle to dynamic shared object. This label is used when
 * global objects are created and constructors are executed before main(). The
 * variable is unused because the feature of destructing global objects after
 * exiting main() is not needed, we never return from main().
 */
void * __dso_handle;

/**
 * __cxa_atexit: Function is used to register destructors for global objects so
 * that global objects can be deinitialized after main() returns. The code is
 * generated by G++ automatically. In our embedded environment the main() never
 * returns, so these destructors would not be executed even if they were
 * registered in some data structure. Because of this, it is safe not to
 * implement the function. Constructors must be called in right order at the
 * right time though.
 */
extern "C" void __cxa_atexit()
{
}
